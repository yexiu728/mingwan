package study.day21;

public class Test0 {
    /*

Test1：装饰设计模式
    装饰模式指的是在不必改变原类文件和使用继承的情况下，
        动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象

Test2：单例设计模式(Singleton)
    Singleton模式主要作用是保证在Java应用程序中,一个类Class只有一个实例存在
    使用单例设计模式的好处还在于可以节省内存,因为他限制了实例的个数
        饿汉式
            创建类时即创建对象，不会在调用时创建
        懒汉式（线程隐患）
            在需要时再判断是否已创建然后返回对象，如果没有创建，则创建再返回。

Test3：模板设计模式
    模版方法模式就是定义一个算法的骨架，而将具体的算法延迟到子类中来实现
        优点和缺点
            * a:优点
            * 使用模版方法模式，在定义算法骨架的同时，可以很灵活的实现具体的算法，满足用户灵活多变的需求
            * b:缺点
            * 如果算法骨架有修改的话，则需要修改抽象类

Test4：工厂设计模式（解耦）
    简单工厂
        一个工厂方法，依据传入的参数，生成对应的产品对象；
        角色： 1、抽象产品 2、具体产品 3、具体工厂
    工厂方法
        将工厂提取成一个接口或抽象类，具体生产什么产品由子类决定；
        角色： 抽象产品类 具体产品类 抽象工厂

Test5：适配器模式(Adapter)
    将某个类的接口转换成客户端期望的另一个接口表示。
    使得原本由于接口不兼容而不能一起工作的那些类能在一起工作。

Test6：枚举(enum)
    枚举其实就是多例，一个类有多个实例，但实例的个数不是无穷的，是有限个数的。
    构造器：
        每个枚举成员被调用时默认执行枚举的构造方法
            一个参数时用value，两个参数时用name和value
        枚举构造器修饰符只能为private，可以省略

*/

}
